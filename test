import os
import time
import pyaudio
import websockets
import asyncio
import json

"""
sudo apt install espeak  # For Linux
brew install espeak      # For macOS
"""
from gtts import gTTS  # gtts==2.2.4

import subprocess
import logging
from datetime import datetime, timedelta

FRAMES_PER_BUFFER = 3200
FORMAT = pyaudio.paInt16
CHANNELS = 1
RATE = 16000
LOG_PREFIX = "[AVATAR_AI]:"

AUDIO_TEXT_FILE = "Audio_Started.txt"
AUDIO_FILE = "Audio_File.txt"
RUNTIME_AUDIO_DIRECTORY = "runtime_audios"

logging.basicConfig(level=logging.INFO, format='%(asctime)s %(name)s %(levelname)s:%(message)s',
                    filename="rc_access_logger.log")
logger = logging.getLogger("recording_bot_logs")
MEETING_ENDED_FILE = "meeting_ended_file.txt"
audio_queue = asyncio.Queue()

HOT_WORDS = {"hey aviso", "hi aviso", "hi viso", "hi veso", "hi lisa"}
QUESTION_MARKS = ["what", "can you", "how", "?", "tell me"]
TTS_SOURCE = "google"

# keyword: text
TEXT_MAPPINGS = {
    "decision making": """Integrating a tool like Aviso enhances decision-making capabilities at all levels of the sales organization. 
        By leveraging centralized insights, real-time analytics, and process automation, sales leaders can confidently make
        strategic choices that drive revenue growth and optimize team performance.""",
    "usability": """Aviso enhances the sales experience by automating routine tasks like transcription and follow-ups, 
        allowing reps to focus on building client relationships. Its intuitive interface ensures seamless adoption,
         enabling teams to access actionable insights effortlessly.""",
    "pricing": """Aviso offers flexible, scalable licensing options tailored to sales team sizes and business needs, 
        ensuring cost-efficiency. Pricing tiers are based on the number of users and advanced feature access, 
        enabling businesses to align costs with their growth.""",
    "demo": """Avisoâ€™s sales-focused demo showcases how the platform streamlines meeting management, automates insights, 
        and enhances team productivity. It provides a hands-on experience of its key features, 
        highlighting real-world applications to drive intent and confidence in adopting the solution."""
}


def text_to_audio_with_ffmpeg_with_google(text, output_file):
    temp_wav, is_created = "temp_audio.mp3", False
    try:
        tts = gTTS(text)
        tts.save(temp_wav)
        subprocess.run(
            [
                "ffmpeg",
                "-i", temp_wav,
                "-vn",  # Disable video
                "-ar", "44100",  # Audio sample rate
                "-ac", "2",  # Audio channels
                "-b:a", "192k",  # Audio bitrate
                output_file
            ],
            check=True
        )
        is_created = True
        print(f"Audio file created: {output_file}")
    except Exception as e:
        print(f"An error occurred: {e}")
    finally:
        # Clean up the temporary file
        if os.path.exists(temp_wav):
            os.remove(temp_wav)
    return is_created


def text_to_audio_with_ffmpeg(text, output_file, voice="en-us", speed="140"):
    """
    :param text: Text to be converted into audio
    :param output_file: audio filename where audio will be created.
    :param voice: The voice to use (default: 'en-us').
    :param speed: The speed in words per minute (default: 140).
    :return: bool
    """
    try:
        # Run espeak and pipe its output to ffmpeg
        espeak_process = subprocess.Popen(
            ['espeak', '-v', voice, '-s', speed, text, '--stdout'],  # espeak command
            stdout=subprocess.PIPE  # Pipe output to ffmpeg
        )

        # Use ffmpeg to process the audio stream
        ffmpeg_process = subprocess.Popen(
            ['ffmpeg', '-i', 'pipe:0', output_file],  # ffmpeg command to read from stdin
            stdin=espeak_process.stdout,  # Connect espeak's output to ffmpeg's input
            stdout=subprocess.DEVNULL,  # Suppress ffmpeg output
            stderr=subprocess.DEVNULL,
            shell=False
        )

        # Wait for both processes to finish
        espeak_process.stdout.close()
        ffmpeg_process.wait()
        print(f"Audio file created: {output_file}")
        if not os.path.exists(AUDIO_FILE):
            f1 = open(AUDIO_FILE, "w")
            f1.write("Audio Started")
            f1.close()
        return True
    except Exception as e:
        print(f"An error occurred: {e}")
        return False


def generate_audio_file_response(ft_text):
    for keyword, text in TEXT_MAPPINGS.items():
        if keyword in ft_text:
            # TODO: add RUNTIME_AUDIO_DIRECTORY
            output_file = f"{keyword}.mp3"
            if TTS_SOURCE == "google":
                is_created = text_to_audio_with_ffmpeg_with_google(text, output_file)
                if is_created:
                    break
            else:
                text_to_audio_with_ffmpeg(text, output_file)
                break


def audio_queue_callback(input_data, frame_count, time_info, status_flags):
    audio_queue.put_nowait(input_data)
    return (input_data, pyaudio.paContinue)


async def microphone(meeting_id):
    while not os.path.exists(AUDIO_TEXT_FILE):
        pass
    audio = pyaudio.PyAudio()
    stream = audio.open(
        format=FORMAT,
        channels=CHANNELS,
        rate=RATE,
        input=True,
        frames_per_buffer=FRAMES_PER_BUFFER,
        stream_callback=audio_queue_callback
    )
    print(f"Realtime Coaching: Audio recording started for meeting: {meeting_id}")
    stream.start_stream()
    while stream.is_active():
        if os.path.exists(MEETING_ENDED_FILE):
            print(f"DG: Breaking microphone because meeting ended file found for meeting: {meeting_id}")
            break
        await asyncio.sleep(0.1)
    stream.stop_stream()
    stream.close()
    return True


async def send_receive(basic_data):
    auth_key = basic_data['auth_key']
    deepgram_model = basic_data.get('deepgram_model', "nova-2-ea")
    meeting_id = basic_data.get("meeting_id", None)
    log_prefix = f"{LOG_PREFIX}: meeting_id='{meeting_id}'"

    if basic_data.get("start_time"):
        stay_in_loop = True
        start_time_ts = datetime.strptime(basic_data['start_time'], "%Y-%m-%dT%H:%M:%SZ")
        while stay_in_loop:
            current_time = datetime.utcnow() + timedelta(seconds=1)
            if current_time >= start_time_ts:
                stay_in_loop = False

    print(f"{log_prefix} Deepgram PyAudio Starting at={time.time()}")
    f1 = open(AUDIO_TEXT_FILE, "w")
    f1.write("Audio Started")
    f1.close()

    async def main_send_receive():
        # the Deepgram endpoint we're going to hit
        url = f'wss://api.deepgram.com/v1/listen?encoding=linear16&sample_rate={RATE}&channels=1&model={deepgram_model}'
        print(f"{log_prefix} Connecting websocket to url='{url}'")
        extra_headers = {
            'Authorization': 'token ' + auth_key
        }
        async with websockets.connect(url, extra_headers=extra_headers) as web_socket:
            print(f"{log_prefix} Websocket connection created with url='{url}'")
            await asyncio.sleep(0.1)
            async def sender():
                while True:
                    try:
                        data = await audio_queue.get()
                        await web_socket.send(data)
                    except websockets.exceptions.ConnectionClosedError as e:
                        print(e)
                        assert e.code == 1011
                        break
                    except Exception as e:
                        if os.path.exists(MEETING_ENDED_FILE):
                            print(f"{log_prefix} Breaking sender because meeting ended file found.")
                            break
                        if "Task" in str(e):
                            continue
                        assert False, "Not a websocket 4008 error"
                    await asyncio.sleep(0.01)
                return True

            async def receiver():
                while True:
                    try:
                        msg = await web_socket.recv()
                        try:
                            json_obj = json.loads(msg)
                            if json_obj['type'] != "Results":
                                continue
                            if not json_obj.get('is_final'):
                                continue
                            alternatives = json_obj['channel']['alternatives']
                            is_audio_generated = False
                            for alternative in alternatives:
                                if is_audio_generated:
                                    break
                                ft_text = alternative['transcript']
                                print(ft_text)
                                if not ft_text:
                                    continue
                                for hot_word in HOT_WORDS:
                                    if is_audio_generated:
                                        break
                                    if not any(mark in ft_text for mark in QUESTION_MARKS):
                                        continue
                                    if hot_word in ft_text:
                                        if os.path.exists(AUDIO_FILE):
                                            continue
                                        generate_audio_file_response(ft_text)
                                        is_audio_generated = True
                        except Exception as exc:
                            print(f"{log_prefix} Error: {exc}")
                            if os.path.exists(MEETING_ENDED_FILE):
                                print(
                                    f"{log_prefix}: Breaking receiver because meeting ended file found.")
                                break
                    except websockets.exceptions.ConnectionClosedError as e:
                        print(e)
                        print(f"{log_prefix}: meeting ended file found.")
                        assert e.code == 1011
                        break
                    except Exception as e:
                        if os.path.exists(MEETING_ENDED_FILE):
                            print(f"{log_prefix}: Breaking receiver because meeting ended file found.")
                            break
                        assert False, "Not a websocket 4008 error"

            await asyncio.gather(sender(), receiver())
            print(f"{log_prefix} Killed receiver and sender.")
        return True

    await asyncio.gather(microphone(meeting_id), main_send_receive())
    print(f"{log_prefix} Killed microphone and main_send_receive.")
    print(f"{log_prefix} Published meeting ended.")
    return True


if __name__ == "__main__":
    # import argparse
    #
    # parser = argparse.ArgumentParser()
    # parser.add_argument("-payload", "-m", type=str, required=True)
    # args = parser.parse_args()
    # request_payload = json.loads(args.payload)
    loop = asyncio.new_event_loop()
    # print(f"{LOG_PREFIX} Request payload - {request_payload}")
    request_payload = {'auth_key': '253c8e379e458e4c08eb26c3ad9bd30752', "meeting_id": "84101717055"}
    loop.run_until_complete(send_receive(request_payload))
